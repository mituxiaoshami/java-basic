类的信息在运行期间是从哪里得到的(RTTI机制主要靠什么来实现)？

在Java中的java.lang包中,存在Class这么一个类，而程序中的每个类都有一个对应的Class的对象，而这个Class的对象其中就包含了对应的类的信息。包括类的变量，类的属性，类的超类，类实现的借口，类的修饰符，类的对应的类的加载器等等
事实上，我们要用Class对象创建属于某个类的全部"常规"或"普通对象"。

那么，什么时候生成Class的对象？

所有类都在第一次使用时，动态加载入jvm当中，当程序创建对类的第一个静态引用时，就会加载这个类，同时构造器可以看作是一个静态方法，同时在生成的.class二进制文件中，会保存一个相应类的一个Class对象。也就是说，每次编写一个新类时，同时也会创建一个Class对象

在运行期，一旦我们想生成那个类的一个对象，Java虚拟机(JVM)首先会检查那个类型的Class对象是否被载入，如果没有，JVM就会查找同名的.class文件，将其载入。

一旦那个类型的Class对象被JVM载入到内存，那么就使用它创建那一类型的所有对象。

从day02.main.SweepShop的代码中可以看出，针对于Class类，虚拟机只会产生一份字节码文件，然后使用这份字节码文件产生多个实例对象，也就是说Java中的每个对象都有相同
的一个Class类对象，前提是对象的类型相同。

因此，我们能通过Class对象知道某个对象"真正"所属的类。无论我们对引用怎样的进行类型转换，对象本身所对应的Class对象都是同一个。
当我们通过某个引用调用方法时，Java程序能自动找到正确的Class类中所定义的方法，并执行该Class类中的代码。

正式由于Class对象的存在，Java不会因为向上造型而造成类型转换迷失，而这就是多态的原理。

在day01.main.Shapes类中，遍历出来的类型都转型成Shape,但是，执行的都是各自子类中的代码，没有因为向上转型而丢失类型。

RTTI的形式：

1、强转的形式,(Shape)，它用RTTI确保转型的正确性，如果失败，则抛出一个ClassCastException异常。这个主要是进行向下类型转换时使用，可以概括为：你是什么类型就可以从基类型转化什么类型
2、代表对象类型的Class对象。可查询Class对象，获取有用的运行期类信息。
3、instanceof 关键字用于检查对象是不是某个特定类型的实例，它会返回一个布尔值，以便问题的形式使用