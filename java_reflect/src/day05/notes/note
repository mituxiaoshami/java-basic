如果不知道一个对象的准确类型，RTTI会帮助我们调查。但是，类型必须是在编译期间已知的，否则就不能使用RTTI机制。

那么什么情况下，我们不知道类型呢？

1、得到的是一个不再自己程序空间内的对象的引用

什么情况下会得到不再自己程序中的对象的引用？
我们从磁盘或者网络获得一系列字节，而且被告知那些字节是一个类。但是，在编译时期，我们不知道那个类的情况，也就是说，在编译期间是未知的。

2、通过网络创建与执行位于远程系统上的对象，叫作"远程方法调用"(RMI),它允许Java程序（jdk 1.1以上）使用多台机器发布或分布的对象。

使用这中情况的场景：可能要做一件计算或者业务繁忙的工作，对这段计算或者业务简化，分割这段业务，使处于空闲状态的其他的机器也能分担其中分割出来的一部分业务。

所以针对于以上两种情况：Java 1.1中，Class类得到了扩展，可以支持"反射"的概念，针对Field,Method以及Constructor类(每个都实现了Memberinterface--成员接口)，java1.1
新建了一个java.lang.reflect。

这些类型的对象都是JVM在运行期创建的，用于表示未知类里对应的成员。
这样可以用构造器创建对象，用get()和set()方法读取和修改与Field对象关联的字段，以及用invoke()方法调用与Method对象关联的方法。
除此之外，我们可调用方法getFields()，getMethod()，getConstructors()，分别返回用于表示字段、方法、以及构造器的对象数组。(其他具体用法看API文档)

因此，匿名对象的类信息可在运行期被完整的揭露出来，而在编译器不需要知道任何东西。


通过"反射"同一个未知类型的对象交互，JVM只是简单地检查这个对象，并调查他从属于哪个特定的类(这点和RTTI一样)。
之后，在我们做其他任何事情之前，Class对象必须载入。因此，用于那种特定类型的.class文件必须能由JVM调用(要么在本地机器内，要么通过网络获取)。所以，RTTI和反射
之间唯一的区别就是：
对RTTI来说，编译器会在编译期打开和检查.class文件。换句话说，我们可以用"普通"方式调用一个对象的所有方法、
对反射来说，.class文件在编译期是不可使用的，而是由运行期环境打开和检查。




总结：

在我们使用多态时，要求我们拥有对基类的控制权，因为有些时候在程序范围之内，可能发现基础类并未包括我们想要的方法。