一: 考虑用静态方法替代构造器:

注意点: 这个静态方法只是一个用来返回类的实例的静态方法

例子: Boolean 包装类

public static final Boolean TRUE = new Boolean(true);

public static final Boolean FALSE = new Boolean(false);

/* 将boolean基本类型值转换成了一个Boolean对象*/
public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
}

静态方法相比构造器的优势:

1、有便于代码阅读理解的名称，便于其他对象调用。

场景: 因为一个类只能存在一个具有指定参数列表的构造器。那么如果要使用相同参数列表的构造器，那么就只能调整参数的顺序，但是这样做很不便于客户端调用。
      面对这样的API，客户端程序员肯定不便于理解和调用。

      但是由于静态方法有名称，所以不受上面的限制。当一个类需要有多个带有相同参数列表的构造器时，就用静态方法代替构造器，并且命名一个合适的名称。

2、不必在每次调用的时候都创建一个新的对象。

场景: 使用构造器时，每次去调用构造器都会返回一个新的类的实例，这样会很容易造成变量的增加。

      但是在上面的例子中可以看到，TRUE和FALSE这两个Boolean类型的变量，在类加载的时候就预先创建，还有一种情况就是将创建好的实例缓存起来，进行重复利用，从而避免创建不必要的对象。
      这种方法类似于设计模式中的享元模式(Flyweight模式)，共享对象的一种思想。
      同时，这样有助于类控制在某个时刻哪些实例应该存在。而这种类被称作实例受控的类。
      实例受控--使得类可以确保它是一个单例或者是不可实例化的。
              --使得不可变的类可以确保不会存在两个相等的实例，也就是可以用"=="来代替equals()方法，提升性能。  枚举类型保证了这一点。

      如果程序经常请求创建相同的对象，并且创建对象的代价很高，那么上面例子中的静态方法是一个很不错的选择。

3、返回原返回类型的任何子类型的对象。

场景: 使用构造器时，返回的都是那个类的一个实例，是什么就是什么，而且客户端调用的时候，构造器必须是公有的，也就是public修饰词修饰。
      使用静态方法时，返回的可以是原类型的一个子类型。这个优点体现在基于接口的框架。

      在基于接口的框架中，接口制定了最基础的返回类型，也就是说，上述的静态方法可以使用接口的类型作为返回类型。
      但是，接口中是不能存在静态方法的，所以，我们通常的做法是，接口类型的静态方法通常被放在一个不可实例化的类中。

      例: java.util 中的Collections类， 你会发现这个类中的构造方法是用private修饰的，说明不能被外部调用，也就是一个不可实例化的类。
          这个类提供了返回不可修改的集合，同步集合等等的静态方法。
          而且这些返回对象都是非公有的，在Collections类中是用private修饰词修饰静态内部类或者protected修饰静态内部类来实现的。






